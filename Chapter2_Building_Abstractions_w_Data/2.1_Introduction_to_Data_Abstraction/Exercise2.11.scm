(include "Exercise2.7.scm")
;points of interval either both positive/negative or spans zero
(define (mul-interval x y)
	(let ((lx (lower-bound x))
		  (ux (upper-bound x))	
		  (ly (lower-bound y))
		  (uy (upper-bound y)))
		(cond ((and 
				(positive? lx)
				(positive? ux)
				(positive? ly)
				(positive? uy)) 
				(make-interval (* lx ly) (* ux uy))	
				)		  
			   ((and
			  	 (positive? lx) 
				 (positive? ux)
				 (non-positive? ly)
				 (non-positive? uy))
				 (make-interval (* ux ly) (* lx uy))
			   )
			   ((and
			  	 (non-positive? lx) 
				 (positive? ux)
				 (non-positive? ly)
				 (non-positive? uy))
				 (make-interval (* ux ly) (* lx ly))
			   )
			   ((and
			 	 (non-positive? lx)  
				 (non-positive? ux)
			  	 (positive? ly) 
				 (positive? uy))
				 (make-interval (* lx uy) (ux ly))
			   )
			   ((and
			  	 (non-positive? lx) 
				 (non-positive? ux)
			  	 (non-positive? ly) 
				 (positive? uy))
				 (make-interval (* lx uy) (* lx ly))
			   )
			   ((and 
			  	(non-positive? lx) 
				(positive? ux)
				(non-positive? ly)
				(positive? uy))
				(let ((p1 (* lx ly))
					  (p2 (* lx uy))	
					  (p3 (* ux ly))
					  (p4 (* ux uy)))
					(make-interval (min (p1 p2 p3 p4)) (max (p1 p2 p3 p4)))		  
				)
			   )
			   ((and
			  	 (non-positive? lx) 
				 (non-positive? ux)
				 (non-positive? ly)
				 (non-positive? uy))
				 (make-interval (* ux uy) (lx ly))
			   )
			   ((and
			  	(non-positive? lx) 
				(positive? ux)
				(positive? ly)
				(positive? uy))
				(make-interval (* lx uy) (* ux uy))
			   )
			   ((and
			  	(positive? lx) 
				(positive? ux)
				(non-positive? ly)
				(positive? uy))
				(make-interval (* ux ly) (* ux uy))
			   )
		)

	)
)

(define (positive? x) (> x 0))

(define (non-positive? x) (<= x 0))